<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebXR Passthrough Galaxies – Quest 3</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; }
    #enterAR { position: fixed; inset: auto 0 24px 0; margin: auto; width: max-content; padding: 12px 18px; border-radius: 999px; border: none; font-size: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.35); cursor: pointer; background: linear-gradient(135deg, #a78bfa, #60a5fa); color: white; }
    #overlay { position: fixed; inset: 0; display: grid; place-items: center; }
    #msg { position: fixed; top: 12px; left: 12px; color: white; font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto; opacity: .8; }
  </style>
</head>
<body>
  <div id="msg">Quest 3 • WebXR Passthrough AR • Diverse Galaxies</div>
  <div id="overlay"><button id="enterAR">Enter Passthrough AR</button></div>
  <canvas id="c"></canvas>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js';

    // --- Renderer / Scene ---
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.xr.enabled = true;

    const scene = new THREE.Scene();
    scene.background = null; // transparent for passthrough

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 2000);
    scene.add(new THREE.AmbientLight(0xffffff, 0.45));

    // --- Utility ---
    function onResize() {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);

    function randomOnSphereRadius(minR, maxR) {
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      const r = minR + Math.random() * (maxR - minR);
      return new THREE.Vector3(
        r * Math.sin(phi) * Math.cos(theta),
        r * Math.sin(phi) * Math.sin(theta),
        r * Math.cos(phi)
      );
    }

    // --- Galaxy Generator (Points) ---
    const GALAXY_TYPES = ['elliptical', 'spiral', 'barred', 'irregular'];

    function hslToRgb(h, s, l) {
      let a = s * Math.min(l, 1 - l);
      const f = n => {
        const k = (n + h * 12) % 12;
        return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      };
      return [f(0), f(8), f(4)];
    }

    function makeGalaxy(type, opts = {}) {
      const group = new THREE.Group();

      // Angular size targets: make galaxies tiny but readable at 25–120 m
      const radius = opts.radius ?? THREE.MathUtils.randFloat(1.2, 5.0); // meters across (visual radius)
      const thickness = opts.thickness ?? THREE.MathUtils.randFloat(0.05, 0.6) * radius; // disk thickness
      const count = opts.count ?? THREE.MathUtils.randInt(400, 1600);

      // Color palettes by type
      let hueBase, sat, light;
      switch (type) {
        case 'elliptical': hueBase = THREE.MathUtils.randFloat(0.05, 0.12); sat = 0.35; light = 0.70; break; // warm/yellowish
        case 'spiral':     hueBase = THREE.MathUtils.randFloat(0.55, 0.65); sat = 0.55; light = 0.65; break; // blue-white
        case 'barred':     hueBase = THREE.MathUtils.randFloat(0.50, 0.58); sat = 0.5;  light = 0.65; break;
        default:           hueBase = THREE.MathUtils.randFloat(0.10, 0.55); sat = 0.45; light = 0.65; break; // irregular variety
      }

      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      const color = new THREE.Color();

      const arms = THREE.MathUtils.randInt(2, 4);
      const twist = THREE.MathUtils.randFloat(2.0, 4.2); // radians of winding to outer edge
      const barLen = THREE.MathUtils.randFloat(0.3, 0.7) * radius;

      for (let i = 0; i < count; i++) {
        let x, y, z;
        if (type === 'elliptical') {
          // 3D ellipsoid with more central density
          const r = radius * Math.pow(Math.random(), 0.5);
          const ang = Math.random() * Math.PI * 2;
          const el = THREE.MathUtils.randFloat(0.5, 0.9); // axis ratio
          x = Math.cos(ang) * r;
          z = Math.sin(ang) * r * el;
          y = (Math.random() - 0.5) * 2 * (thickness * 0.8);
        } else if (type === 'spiral') {
          const t = Math.pow(Math.random(), 0.7); // radii bias to center
          const r = t * radius;
          const arm = (i % arms) / arms;
          const ang = arm * Math.PI * 2 + twist * t + THREE.MathUtils.randFloatSpread(0.15);
          const jitter = (1 - t) * 0.08 * radius;
          x = Math.cos(ang) * r + THREE.MathUtils.randFloatSpread(jitter);
          z = Math.sin(ang) * r + THREE.MathUtils.randFloatSpread(jitter);
          y = THREE.MathUtils.randFloatSpread(thickness * 0.4);
        } else if (type === 'barred') {
          const t = Math.pow(Math.random(), 0.7);
          const r = t * radius;
          let ang;
          if (Math.random() < 0.35) {
            // points along the central bar
            const u = THREE.MathUtils.randFloatSpread(1);
            x = u * barLen;
            z = THREE.MathUtils.randFloatSpread(0.15 * thickness);
          } else {
            // arms leaving the bar
            const arm = (i % arms) / arms;
            ang = arm * Math.PI * 2 + twist * t + THREE.MathUtils.randFloatSpread(0.12);
            x = Math.cos(ang) * r;
            z = Math.sin(ang) * r;
          }
          y = THREE.MathUtils.randFloatSpread(thickness * 0.4);
        } else { // irregular
          const r = radius * Math.pow(Math.random(), 0.3);
          const ang = Math.random() * Math.PI * 2;
          x = Math.cos(ang) * r + THREE.MathUtils.randFloatSpread(0.25 * radius);
          z = Math.sin(ang) * r + THREE.MathUtils.randFloatSpread(0.25 * radius);
          y = THREE.MathUtils.randFloatSpread(thickness);
        }

        const idx = i * 3;
        positions[idx] = x; positions[idx + 1] = y; positions[idx + 2] = z;

        const hue = (hueBase + THREE.MathUtils.randFloatSpread(0.06) + 1) % 1;
        const satJ = THREE.MathUtils.clamp(sat + THREE.MathUtils.randFloatSpread(0.15), 0.15, 0.9);
        const lightJ = THREE.MathUtils.clamp(light + THREE.MathUtils.randFloatSpread(0.15), 0.45, 0.85);
        const [rr, gg, bb] = hslToRgb(hue, satJ, lightJ);
        colors[idx] = rr; colors[idx + 1] = gg; colors[idx + 2] = bb;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      const mat = new THREE.PointsMaterial({ size: 0.02, sizeAttenuation: true, transparent: true, opacity: 0.9, vertexColors: true, depthWrite: false, blending: THREE.AdditiveBlending });
      const pts = new THREE.Points(geo, mat);
      group.add(pts);

      // Random 3D orientation so shapes aren't all face-on
      group.quaternion.setFromEuler(new THREE.Euler(
        THREE.MathUtils.randFloat(-Math.PI, Math.PI),
        THREE.MathUtils.randFloat(-Math.PI, Math.PI),
        THREE.MathUtils.randFloat(-Math.PI, Math.PI)
      ));

      // Slow drift/rotation
      group.userData.spin = new THREE.Vector3(
        THREE.MathUtils.randFloat(-0.0003, 0.0003),
        THREE.MathUtils.randFloat(-0.0003, 0.0003),
        THREE.MathUtils.randFloat(-0.0003, 0.0003)
      );

      return group;
    }

    // --- Populate sky with believable sizes & spacing ---
    const galaxies = [];
    const COUNT = 120; // not too dense
    const MIN_DIST = 25; // meters
    const MAX_DIST = 120; // meters

    for (let i = 0; i < COUNT; i++) {
      const type = GALAXY_TYPES[Math.floor(Math.random() * GALAXY_TYPES.length)];
      const g = makeGalaxy(type);
      const p = randomOnSphereRadius(MIN_DIST, MAX_DIST);
      g.position.copy(p);
      scene.add(g);
      galaxies.push(g);
    }

    // --- Animate ---
    renderer.setAnimationLoop((t) => {
      for (const g of galaxies) {
        const s = g.userData.spin;
        g.rotation.x += s.x; g.rotation.y += s.y; g.rotation.z += s.z;
      }
      renderer.render(scene, camera);
    });

    // --- WebXR Passthrough handling ---
    const button = ARButton.createButton(renderer, { requiredFeatures: ['local'] });
    const overlay = document.getElementById('overlay');
    overlay.replaceChildren(button);

    renderer.xr.addEventListener('sessionstart', () => overlay.style.display = 'none');
    renderer.xr.addEventListener('sessionend',   () => overlay.style.display = 'grid');
  </script>
</body>
</html>
